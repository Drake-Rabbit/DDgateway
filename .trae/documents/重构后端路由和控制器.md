# 重构后端路由和控制器

## 目标

1. 将路由定义从 `main.go` 分离出来，创建独立的路由文件
2. 修改控制器实现，不再需要接收 `service` 作为参数，而是通过结构体注入服务实例

## 实现方案

### 1. 创建路由包

- 创建 `internal/router` 目录和 `router.go` 文件
- 将 `main.go` 中的路由定义迁移到 `router.go`
- 定义 `SetupRouter` 函数，接收配置、数据库连接等依赖，返回配置好的路由

### 2. 修改控制器实现

- 将控制器从函数改为结构体，包含服务实例字段
- 为每个控制器添加构造函数，注入相应的服务实例
- 将原有控制器函数改为结构体方法

### 3. 修改 main.go

- 初始化服务实例
- 初始化控制器实例（注入服务）
- 调用 `SetupRouter` 函数配置路由
- 启动服务器

## 具体步骤

### 步骤 1: 创建路由文件

```go
// internal/router/router.go
package router

import (
	"gateway-service/internal/config"
	"gateway-service/internal/controller"
	"gateway-service/internal/middleware"
	"gateway-service/pkg/response"

	"github.com/gin-gonic/gin"
)

// SetupRouter configures all routes for the application
func SetupRouter(cfg *config.Config, userController *controller.UserController, tenantController *controller.TenantController, authController *controller.AuthController) *gin.Engine {
	// Initialize Gin router
	r := gin.Default()

	// Setup CORS
	r.Use(middleware.CORS())

	// Setup response helper
	response.Setup(r)

	// API routes
	api := r.Group("/api")
	{
		// Public routes
		auth := api.Group("/auth")
		{
			auth.GET("/register", authController.Register)
			auth.POST("/register", authController.Register)
			auth.GET("/login", authController.Login)
			auth.POST("/login", authController.Login)
		}

		// Protected routes (require authentication)
		protected := api.Group("")
		protected.Use(middleware.AuthMiddleware(cfg.JWT.Secret))
		{
			// Tenant routes (require tenant identification)
			tenantRoutes := protected.Group("/tenants")
			tenantRoutes.Use(middleware.TenantMiddleware())
			{
				tenantRoutes.GET("", tenantController.ListTenants)
				tenantRoutes.POST("", tenantController.ListTenants)
				tenantRoutes.GET("/detail/:id", tenantController.GetTenant)
				tenantRoutes.POST("/detail/:id", tenantController.GetTenant)
				tenantRoutes.GET("/create", tenantController.CreateTenant)
				tenantRoutes.POST("/create", tenantController.CreateTenant)
				tenantRoutes.GET("/update/:id", tenantController.UpdateTenant)
				tenantRoutes.POST("/update/:id", tenantController.UpdateTenant)
				tenantRoutes.GET("/delete/:id", tenantController.DeleteTenant)
				tenantRoutes.POST("/delete/:id", tenantController.DeleteTenant)
			}

			// User routes
			users := protected.Group("/users")
			users.Use(middleware.TenantMiddleware())
			{
				users.GET("", userController.ListUsers)
				users.GET("/detail/:id", userController.GetUser)
				users.POST("/detail/:id", userController.GetUser)
				users.GET("/update/:id", userController.UpdateUser)
				users.POST("/update/:id", userController.UpdateUser)
				users.GET("/delete/:id", userController.DeleteUser)
				users.POST("/delete/:id", userController.DeleteUser)
			}
		}
	}

	// Health check
	r.GET("/health", func(c *gin.Context) {
		response.Success(c, gin.H{"status": "ok"})
	})

	return r
}
```

### 步骤 2: 修改控制器为结构体

#### UserController

```go
// internal/controller/user.go
package controller

import (
	"gateway-service/internal/service"
	"gateway-service/pkg/response"

	"github.com/gin-gonic/gin"
)

// UserController handles user-related requests
type UserController struct {
	userService *service.UserService
}

// NewUserController creates a new UserController instance
func NewUserController(userService *service.UserService) *UserController {
	return &UserController{userService: userService}
}

// ListUsers returns all users for the current tenant
func (c *UserController) ListUsers(ctx *gin.Context) {
	tenantID := ctx.GetUint("current_tenant_id")

	users, err := c.userService.ListUsers(tenantID)
	if err != nil {
		response.InternalError(ctx, "Failed to fetch users")
		return
	}

	response.Success(ctx, users)
}

// GetUser returns a single user by ID
func (c *UserController) GetUser(ctx *gin.Context) {
	tenantID := ctx.GetUint("current_tenant_id")
	id := ctx.Param("id")

	user, err := c.userService.GetUser(tenantID, id)
	if err != nil {
		response.NotFound(ctx, "User not found")
		return
	}

	response.Success(ctx, user)
}

// UpdateUser updates an existing user
func (c *UserController) UpdateUser(ctx *gin.Context) {
	tenantID := ctx.GetUint("current_tenant_id")
	id := ctx.Param("id")

	var req struct {
		Email  string `json:"email"`
		Role   string `json:"role"`
		Status string `json:"status"`
	}

	if err := ctx.ShouldBindJSON(&req); err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	user, err := c.userService.UpdateUser(tenantID, id, req.Email, req.Role, req.Status)
	if err != nil {
		response.NotFound(ctx, "User not found")
		return
	}

	response.Success(ctx, user)
}

// DeleteUser deletes a user
func (c *UserController) DeleteUser(ctx *gin.Context) {
	tenantID := ctx.GetUint("current_tenant_id")
	id := ctx.Param("id")

	err := c.userService.DeleteUser(tenantID, id)
	if err != nil {
		response.NotFound(ctx, "User not found")
		return
	}

	response.Success(ctx, gin.H{"message": "User deleted successfully"})
}
```

#### TenantController

```go
// internal/controller/tenant.go
package controller

import (
	"gateway-service/internal/service"
	"gateway-service/pkg/response"

	"github.com/gin-gonic/gin"
)

// TenantController handles tenant-related requests
type TenantController struct {
	tenantService *service.TenantService
}

// NewTenantController creates a new TenantController instance
func NewTenantController(tenantService *service.TenantService) *TenantController {
	return &TenantController{tenantService: tenantService}
}

// ListTenants returns all tenants
func (c *TenantController) ListTenants(ctx *gin.Context) {
	tenants, err := c.tenantService.ListTenants()
	if err != nil {
		response.InternalError(ctx, "Failed to fetch tenants")
		return
	}

	response.Success(ctx, tenants)
}

// GetTenant returns a single tenant by ID
func (c *TenantController) GetTenant(ctx *gin.Context) {
	id := ctx.Param("id")

	tenant, err := c.tenantService.GetTenant(id)
	if err != nil {
		response.NotFound(ctx, "Tenant not found")
		return
	}

	response.Success(ctx, tenant)
}

// CreateTenant creates a new tenant
func (c *TenantController) CreateTenant(ctx *gin.Context) {
	var req struct {
		Name        string `json:"name" binding:"required"`
		Code        string `json:"code" binding:"required"`
		Description string `json:"description"`
	}

	if err := ctx.ShouldBindJSON(&req); err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	tenant, err := c.tenantService.CreateTenant(req.Name, req.Code, req.Description)
	if err != nil {
		response.InternalError(ctx, "Failed to create tenant")
		return
	}

	response.Success(ctx, tenant)
}

// UpdateTenant updates an existing tenant
func (c *TenantController) UpdateTenant(ctx *gin.Context) {
	id := ctx.Param("id")

	var req struct {
		Name        string `json:"name"`
		Description string `json:"description"`
		Status      string `json:"status"`
	}

	if err := ctx.ShouldBindJSON(&req); err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	tenant, err := c.tenantService.UpdateTenant(id, req.Name, req.Description, req.Status)
	if err != nil {
		response.NotFound(ctx, "Tenant not found")
		return
	}

	response.Success(ctx, tenant)
}

// DeleteTenant deletes a tenant
func (c *TenantController) DeleteTenant(ctx *gin.Context) {
	id := ctx.Param("id")

	err := c.tenantService.DeleteTenant(id)
	if err != nil {
		response.NotFound(ctx, "Tenant not found")
		return
	}

	response.Success(ctx, gin.H{"message": "Tenant deleted successfully"})
}
```

#### AuthController

```go
// internal/controller/login_auth.go
package controller

import (
	"gateway-service/internal/config"
	"gateway-service/internal/service"
	"gateway-service/pkg/jwt"
	"gateway-service/pkg/response"
	"time"

	"github.com/gin-gonic/gin"
)

// AuthController handles authentication-related requests
type AuthController struct {
	userService *service.UserService
	cfg         *config.Config
}

// NewAuthController creates a new AuthController instance
func NewAuthController(userService *service.UserService, cfg *config.Config) *AuthController {
	return &AuthController{userService: userService, cfg: cfg}
}

// Register creates a new user
func (c *AuthController) Register(ctx *gin.Context) {
	var req struct {
		Username   string `json:"username" binding:"required"`
		Email      string `json:"email" binding:"required,email"`
		Password   string `json:"password" binding:"required,min=6"`
		TenantCode string `json:"tenant_code" binding:"required"`
	}

	if err := ctx.ShouldBindJSON(&req); err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	// Call user service to register user
	user, err := c.userService.Register(service.RegisterRequest{
		Username:   req.Username,
		Email:      req.Email,
		Password:   req.Password,
		TenantCode: req.TenantCode,
	})
	if err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	// Generate JWT token
	token, err := jwt.GenerateToken(user.ID, user.TenantID, user.Username, user.Role, c.cfg.JWT.Secret, c.cfg.JWT.ExpireHours)
	if err != nil {
		response.InternalError(ctx, "Failed to generate token")
		return
	}

	response.Success(ctx, gin.H{
		"token": token,
		"user":  user,
	})
}

// Login authenticates a user
func (c *AuthController) Login(ctx *gin.Context) {
	var req struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
	}

	if err := ctx.ShouldBindJSON(&req); err != nil {
		response.BadRequest(ctx, err.Error())
		return
	}

	// Call user service to login
	user, err := c.userService.Login(service.LoginRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		if err.Error() == "user account is inactive" {
			response.Forbidden(ctx, err.Error())
		} else {
			response.Unauthorized(ctx, err.Error())
		}
		return
	}

	// Update last login
	now := time.Now()
	user.LastLogin = &now
	if err := c.userService.UpdateLastLogin(user); err != nil {
		// Just log the error, don't fail the login
	}

	// Generate JWT token
	token, err := jwt.GenerateToken(user.ID, user.TenantID, user.Username, user.Role, c.cfg.JWT.Secret, c.cfg.JWT.ExpireHours)
	if err != nil {
		response.InternalError(ctx, "Failed to generate token")
		return
	}

	response.Success(ctx, gin.H{
		"token": token,
		"user":  user,
	})
}
```

### 3. 修改 main.go

```go
package main

import (
	"gateway-service/internal/config"
	"gateway-service/internal/controller"
	"gateway-service/internal/database"
	"gateway-service/internal/router"
	"gateway-service/internal/service"
	"log"
)

func main() {
	// Load configuration
	cfg := config.Load()

	// Initialize database
	db, err := database.InitDB(cfg)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	// Initialize services
	userService := service.NewUserService(db)
	tenantService := service.NewTenantService(db)

	// Initialize controllers
	userController := controller.NewUserController(userService)
	tenantController := controller.NewTenantController(tenantService)
	authController := controller.NewAuthController(userService, cfg)

	// Setup router
	r := router.SetupRouter(cfg, userController, tenantController, authController)

	// Start server
	addr := ":" + cfg.Server.Port
	log.Printf("Server starting on %s", addr)
	if err := r.Run(addr); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}
```

## 优势

1. **路由分离**：路由定义集中在 `router.go` 文件中，便于管理和维护
2. **控制器结构体**：通过结构体注入服务实例，不再需要将服务作为参数传递给每个控制器函数
3. **依赖清晰**：控制器的依赖关系通过构造函数明确，便于测试和维护
4. **代码组织**：各模块职责清晰，符合单一职责原则
5. **可扩展性**：便于后续添加新的路由和控制器

## 影响范围

- `main.go`：修改初始化流程，调用路由配置函数
- `internal/controller/`：修改所有控制器实现，从函数改为结构体
- 新增 `internal/router/`：添加路由配置文件

## 验证方法

1. 编译项目：`go build`
2. 运行项目：`./gateway-service`
3. 测试API：使用curl或Postman测试所有API端点，确保功能正常